

def mcd(a, b):
	if b > a:
		a, b = b, a
	while b != 0:
		a, b = b , a % b
	return a

def bezout(aux, n_1 , n_2):
	return (int(n_1 - (aux * n_2)))

def euclidean(a, b):
	aux_a , aux_b = a, b
	mcd_number = mcd(a,b)
	#print(f"El MCD de {a} y {b} es {mcd_number}")
	x_1, x_2, y_1, y_2 = 1, 0, 0, 1
	x, y = x_1, y_1
	while a % b >= mcd_number:
		aux = int(a / b)
		x = bezout(aux, x_1, x_2)
		y = bezout(aux, y_1, y_2)
		x_1, x_2 = x_2, x
		y_1, y_2 = y_2, y
		a, b = b , a % b
		#print(f"Los nuevos valores de a y b son {a} y {b}. Cociente = {aux}, x = {x}, y = {y}")
	aux = int(a / b) 
	print(f"MCD = {mcd_number}. Ecuacion : {mcd_number} = {x}*{aux_a} + {y}*{aux_b}")
	return x,y

#ENCRYPTER & DECRPYTER
def decrypt(c,d,n):
     return pow(c,d,n)

def encrypt(m,e,n):
     result = pow(m,e,n)
     print(f"c = {result}")
     
def ext_euclidean(a, b):
    if a == 0:
        return b, 0, 1
    else:
        gcd, x, y = ext_euclidean(b % a, a)
        return gcd, y - (b // a) * x, x
    
def calculate_divisors(n):
    i = 2
    factors = []
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)
    return factors


def n_known(n):
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
    return i, n

def phi_n(p,q):
      result = (p-1)*(q-1)
      return result

def long_to_bytes(message):
    byte_count = (message.bit_length() + 7) // 8  # redondear hacia arriba
    return message.to_bytes(byte_count, 'big')

def main():
    ct = 814602066169451977605898206043894866509050772237095352345693280423339237890197181768582210420699418615050495985283410604981870683596059562903004295804358339676736292824636301426917335460641348021235478618173522948941541432284037580201234570619769478956374067742134884689871240482950578532380612988605675957629342412670503628580284821612200740753343166428553552463950037371300722459849775674636165297063660872395712545246380895584677099483139705934844856029861773030472761407204967590283582345034506802227442338228782131928742229041926847011673393223237610854842559028007551817527116991453411203276872464110797091619
    n = 18644771606497209714095542646224677588981048892455227811334258151262006531336794833359381822210403450387218291341636672728427659163488688386134401896278003165147721355406911673373424263190196921309228396204979060454870860816745503197616145647490864293442635906688253552867657780735555566444060335096583505652012496707636862307239874297179019995999007369981828074059533709513179171859521707075639202212109180625048226522596633441264313917276824985895380863669296036099693167611788521865367087640318827068580965890143181999375133385843774794990578010917043490614806222432751894223475655601237073207615381387441958773717
    e = 0x10001 #65537
   # p,q = n_known(n)
    p = 136545858986998246186017611284664707398999797498692946608523559469499827972094856292942650773093192162138423617662757531574919967461255241533395505995030617210156281091030371701198122810180540132811734185012657022629634425970608413451030604056026161196348671111947083652764868355722990294951453693249819907769
    q = 136545858986998246186017611284664707398999797498692946608523559469499827972094856292942650773093192162138423617662757531574919967461255241533395505995030621481175031499344949735265383560242346915071826552296754272942746356998125287415246140255211942791159132750757895494949215741681277852308288626896929744893
    print(f"p:{p}\nq:{q}\n")
    phi = phi_n(p,q)
    gcd, x, y = ext_euclidean(e, phi)
    if gcd != 1:
        raise Exception('Inverso multiplicativo no existe')
    else:
        d = x % phi
    print(f"d: {d}\n")
    message =decrypt(ct,d,n)
    message_bytes = long_to_bytes(message)
    print(f"{message_bytes}")
main()